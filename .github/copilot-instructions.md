# OllamaRPG Autonomous Game - Development Guidelines

## Project Overview

This is an autonomous RPG where AI controls both the protagonist and NPCs using GOAP (Goal-Oriented Action Planning) and Ollama LLM integration. Players observe the emergent story rather than directly controlling characters.

## Technology Stack

- **Platform**: Electron (Desktop app, no web server)
- **Rendering**: Phaser 3 (2D game engine)
- **UI**: React + Zustand (state management)
- **Styling**: TailwindCSS
- **AI**: GOAP planner + Ollama LLM (local)
- **Pathfinding**: PathFinding.js (A* algorithm)
- **Build**: Vite (bundler)
- **Language**: JavaScript (ES modules)

## Architecture Principles

1. **Separation of Concerns**: Game logic, rendering, and UI are separated
2. **Testability First**: Headless mode for testing without rendering
3. **Event-Driven**: Systems communicate via EventBus
4. **Deterministic**: Seeded RNG for replay system
5. **ECS-inspired**: Systems process entities with components

## Key Systems

### 1. GOAP AI System
- **GOAPPlanner**: A* planning in state space
- **GOAPAction**: Base action class (MoveTo, TalkTo, EnterBuilding, etc.)
- **GOAPGoal**: High-level goals generated by LLM
- **WorldState**: Key-value pairs representing game state

### 2. LLM Integration
- **OllamaService**: Singleton managing LLM calls
- **GoalGenerator**: LLM → Goals
- **DialogueGenerator**: LLM → Dialogue
- **PromptBuilder**: Context → Prompts
- **Seeded calls**: Every LLM call uses deterministic seed

### 3. Replay System
- **ReplayLogger**: Records events, not state
- **ReplayEngine**: Playback with rewind/fast-forward
- **CheckpointManager**: Periodic state snapshots
- **Deterministic**: Same inputs → same outputs

### 4. Character Systems
- **Personality**: 6-trait system (aggression, friendliness, intelligence, caution, greed, honor)
- **Memory**: Time-based decay, relevance scoring
- **Relationships**: -100 to +100 scale
- **Schedules**: Daily routines for NPCs

## Code Style

### File Organization
```
src/
  core/        - Game engine, clock, state
  entities/    - Character, NPC, Protagonist, Building
  components/  - ECS components (Position, Sprite, AI, Memory, etc.)
  systems/     - ECS systems (Movement, GOAP, Dialogue, etc.)
  ai/          - GOAP, LLM, pathfinding, memory
  services/    - Singletons (Ollama, Pathfinding, Replay, etc.)
  state/       - Zustand stores
  ui/          - React components
  rendering/   - Phaser scenes and renderers
  utils/       - SeededRandom, EventBus, Logger
```

### Naming Conventions
- **Classes**: PascalCase (`GOAPPlanner`, `CharacterAI`)
- **Files**: PascalCase for classes (`GOAPPlanner.js`)
- **Functions**: camelCase (`generateGoal`, `findPath`)
- **Constants**: UPPER_SNAKE_CASE (`MAX_MEMORY_SIZE`)
- **React Components**: PascalCase (`CharacterPanel.jsx`)

### Import Aliases (configured in vite.config.js)
```javascript
import { GameEngine } from '@core/GameEngine';
import { Character } from '@entities/Character';
import { MovementSystem } from '@systems/MovementSystem';
import { OllamaService } from '@services/OllamaService';
import { useGameStore } from '@state/gameStore';
```

### Code Patterns

#### Service Pattern (Singleton)
```javascript
class OllamaService {
  constructor(config) {
    this.config = config;
  }
  
  static getInstance(config) {
    if (!this.instance) {
      this.instance = new OllamaService(config);
    }
    return this.instance;
  }
}
```

#### System Pattern (ECS-inspired)
```javascript
class MovementSystem {
  constructor(priority = 10) {
    this.name = 'MovementSystem';
    this.priority = priority;
  }
  
  update(deltaTime, gameState) {
    const characters = gameState.world.getEntitiesByType('Character');
    // Process characters
  }
}
```

#### Event Pattern
```javascript
import { EventBus } from '@services/EventBus';

// Emit
EventBus.emit('movement:completed', { characterId, position });

// Listen
EventBus.on('movement:completed', (data) => {
  // Handle event
});
```

#### Deterministic RNG
```javascript
import { SeededRandom } from '@utils/SeededRandom';

// NEVER use Math.random()
// ALWAYS use gameRNG
const value = gameRNG.next(); // 0 to 1
const int = gameRNG.nextInt(0, 100); // 0 to 100
```

## Testing

### Unit Tests
- Use Vitest
- Test systems in isolation
- Mock services with jest.fn()

### Integration Tests
- Test system interactions
- Use headless mode

### Replay Tests
- Record gameplay
- Verify determinism
- Regression testing

## Common Tasks

### Adding a New GOAP Action
1. Create class in `src/ai/goap/actions/`
2. Extend `GOAPAction`
3. Define preconditions and effects
4. Implement `execute()` method
5. Register in action list

### Adding a New System
1. Create class in `src/systems/`
2. Extend `System`
3. Set priority (lower = runs first)
4. Implement `update(deltaTime, gameState)`
5. Register in SystemRegistry

### Adding a New React Component
1. Create `.jsx` file in `src/ui/components/`
2. Use Zustand for state management
3. Follow existing component patterns
4. Use TailwindCSS for styling

### Logging Events for Replay
```javascript
replayLogger.logEvent(
  gameState.currentFrame,
  'action_completed',
  { actionType: 'MoveTo', result: true },
  character.id
);
```

### LLM Integration
```javascript
// Always use OllamaService with seeded calls
const ollamaService = OllamaService.getInstance();
const response = await ollamaService.generate(prompt, {
  temperature: 0.7,
  seed: seedManager.getNextSeed(characterId, 'goal')
});

// Log the call
replayLogger.logLLMCall({
  callId,
  characterId,
  prompt,
  response,
  seed,
  frame: gameState.currentFrame
});
```

## Performance Guidelines

- Keep frame budget: 16.67ms (60 FPS)
- Avoid synchronous LLM calls in game loop
- Use async/await for LLM generation
- Implement viewport culling in rendering
- Batch pathfinding calculations
- Use object pooling for frequently created objects

## Documentation

- Add JSDoc comments for public methods
- Document GOAP actions with preconditions/effects
- Keep design docs updated
- Comment complex algorithms only

## Git Workflow

- Feature branches: `feature/goap-planning`
- Bug fixes: `fix/dialogue-timing`
- Commit messages: Conventional commits format
  - `feat: add dialogue system`
  - `fix: character pathfinding stuck`
  - `docs: update GOAP action list`

## Important Notes

1. **Never use Math.random()** - Always use `gameRNG.next()`
2. **Never use Date.now()** - Always use `gameState.currentFrame` or `gameClock.gameTime`
3. **Always log to replay** - Use `replayLogger.logEvent()`
4. **Keep deterministic** - Same seed → same results
5. **Service singletons** - Use `Service.getInstance()`
6. **Event-driven** - Use EventBus for system communication

## Resources

- Architecture: See `ARCHITECTURE.md`
- Game Design: See `GAME_CONCEPT_AND_DESIGN.md`
- Replay System: See `REPLAY_SYSTEM_DESIGN.md`
- Web Concept: See `WEB_GAME_CONCEPT.md`
- Phaser 3 Docs: https://photonstorm.github.io/phaser3-docs/
- PathFinding.js: https://github.com/qiao/PathFinding.js
- Ollama API: https://github.com/ollama/ollama/blob/main/docs/api.md

## Quick Start

```bash
# Install dependencies
npm install

# Run in development mode
npm run dev

# Build for production
npm run build

# Run tests
npm test

# Package for distribution
npm run package
```

## Agent-Specific Guidelines

When working on this project:
1. Check existing architecture before creating new patterns
2. Follow the established folder structure
3. Use import aliases for cleaner imports
4. Test in headless mode first
5. Verify determinism with replay system
6. Keep components small and focused
7. Document complex GOAP logic
8. Handle async LLM calls gracefully
9. Consider performance (60 FPS target)
10. Maintain separation between game logic and rendering
